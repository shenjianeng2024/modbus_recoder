import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { vi } from 'vitest';
import { DataReader } from '../DataReader';
import { useAddressRanges } from '../../hooks/useAddressRanges';
import { useErrorHandler } from '../../hooks/useErrorHandler';
import { notifications } from '../../utils/notifications';
import { invoke } from '@tauri-apps/api/core';
import { TooltipProvider } from '@/components/ui/tooltip';

// Mock dependencies
vi.mock('@tauri-apps/api/core');
vi.mock('../../hooks/useAddressRanges');
vi.mock('../../hooks/useErrorHandler');
vi.mock('../../utils/notifications');

const mockInvoke = vi.mocked(invoke);
const mockUseAddressRanges = vi.mocked(useAddressRanges);
const mockUseErrorHandler = vi.mocked(useErrorHandler);
const mockNotifications = vi.mocked(notifications);

describe('DataReader', () => {
  const mockConnectionConfig = {
    ip: '192.168.1.100',
    port: 502
  };

  const mockHandleError = vi.fn();

  beforeEach(() => {
    vi.clearAllMocks();

    // Mock useErrorHandler
    mockUseErrorHandler.mockReturnValue({
      handleError: mockHandleError,
      clearAllErrors: vi.fn(),
      errors: [],
      errorCount: 0
    });

    // Mock notifications
    mockNotifications.loading.mockReturnValue('loading-toast-id');
    mockNotifications.dismiss.mockImplementation(() => {});
    mockNotifications.success.mockImplementation(() => {});
    mockNotifications.error.mockImplementation(() => {});
    mockNotifications.warning.mockImplementation(() => {});
  });

  describe('Component Rendering', () => {
    it('Ê∏≤ÊüìÂü∫Êú¨ÁªÑ‰ª∂ÁªìÊûÑ', () => {
      mockUseAddressRanges.mockReturnValue({
        ranges: [],
        addRange: vi.fn(),
        updateRange: vi.fn(),
        removeRange: vi.fn(),
        clearAllRanges: vi.fn(),
        validateRange: vi.fn(),
        checkOverlaps: vi.fn(),
        totalAddresses: 0,
        exportConfig: vi.fn(),
        importConfig: vi.fn(),
        isLoading: false,
        error: null
      });

      render(
        <TooltipProvider>
          <DataReader connectionConfig={mockConnectionConfig} />
        </TooltipProvider>
      );

      expect(screen.getByText('ÂçïÊ¨°Êï∞ÊçÆËØªÂèñ')).toBeInTheDocument();
      expect(screen.getByText('Á´ãÂç≥ËØªÂèñ')).toBeInTheDocument();
      expect(screen.getByText('Ê†ºÂºè:')).toBeInTheDocument();
      expect(screen.getByText('Áä∂ÊÄÅ:')).toBeInTheDocument();
      expect(screen.getByText('Á©∫Èó≤')).toBeInTheDocument();
    });

    it('ÂΩìÊ≤°ÊúâÂêØÁî®Âú∞ÂùÄÊÆµÊó∂ÊòæÁ§∫Ë≠¶Âëä', () => {
      mockUseAddressRanges.mockReturnValue({
        ranges: [
          {
            id: '1',
            name: 'Range 1',
            startAddress: 1000,
            length: 10,
            dataType: 'uint16',
            enabled: false
          }
        ],
        addRange: vi.fn(),
        updateRange: vi.fn(),
        removeRange: vi.fn(),
        clearAllRanges: vi.fn(),
        validateRange: vi.fn(),
        checkOverlaps: vi.fn(),
        totalAddresses: 10,
        exportConfig: vi.fn(),
        importConfig: vi.fn(),
        isLoading: false,
        error: null
      });

      render(
        <TooltipProvider>
          <DataReader connectionConfig={mockConnectionConfig} />
        </TooltipProvider>
      );

      expect(screen.getByText(/Êó†ÂèØËØªÂèñÁöÑÂú∞ÂùÄÊÆµ/)).toBeInTheDocument();
      expect(screen.getByRole('button', { name: /Á´ãÂç≥ËØªÂèñ/ })).toBeDisabled();
    });

    it('ÂΩìÊúâÂêØÁî®Âú∞ÂùÄÊÆµÊó∂ÊòæÁ§∫ÁªüËÆ°‰ø°ÊÅØ', () => {
      mockUseAddressRanges.mockReturnValue({
        ranges: [
          {
            id: '1',
            name: 'Range 1',
            startAddress: 1000,
            length: 10,
            dataType: 'uint16',
            enabled: true
          },
          {
            id: '2',
            name: 'Range 2',
            startAddress: 2000,
            length: 5,
            dataType: 'float32',
            enabled: true
          }
        ],
        addRange: vi.fn(),
        updateRange: vi.fn(),
        removeRange: vi.fn(),
        clearAllRanges: vi.fn(),
        validateRange: vi.fn(),
        checkOverlaps: vi.fn(),
        totalAddresses: 15,
        exportConfig: vi.fn(),
        importConfig: vi.fn(),
        isLoading: false,
        error: null
      });

      render(
        <TooltipProvider>
          <DataReader connectionConfig={mockConnectionConfig} />
        </TooltipProvider>
      );

      expect(screen.getByText('üìç Â∑≤ÂêØÁî®Âú∞ÂùÄÊÆµ: 2 ‰∏™')).toBeInTheDocument();
      expect(screen.getByText('üìä ÊÄªÂú∞ÂùÄÊï∞: 15 ‰∏™')).toBeInTheDocument();
      expect(screen.getByRole('button', { name: /Á´ãÂç≥ËØªÂèñ/ })).not.toBeDisabled();
    });

    it('ÂΩìdisabled prop‰∏∫trueÊó∂Á¶ÅÁî®ËØªÂèñÊåâÈíÆ', () => {
      mockUseAddressRanges.mockReturnValue({
        ranges: [
          {
            id: '1',
            name: 'Range 1',
            startAddress: 1000,
            length: 10,
            dataType: 'uint16',
            enabled: true
          }
        ],
        addRange: vi.fn(),
        updateRange: vi.fn(),
        removeRange: vi.fn(),
        clearAllRanges: vi.fn(),
        validateRange: vi.fn(),
        checkOverlaps: vi.fn(),
        totalAddresses: 10,
        exportConfig: vi.fn(),
        importConfig: vi.fn(),
        isLoading: false,
        error: null
      });

      render(
        <TooltipProvider>
          <DataReader connectionConfig={mockConnectionConfig} disabled={true} />
        </TooltipProvider>
      );

      expect(screen.getByRole('button', { name: /Á´ãÂç≥ËØªÂèñ/ })).toBeDisabled();
    });
  });

  describe('Reading Functionality', () => {
    const mockBatchResult = {
      results: [
        {
          address: 1000,
          raw_value: 12345,
          parsed_value: '12345',
          timestamp: '2025-09-09T12:34:56Z',
          success: true,
          data_type: 'uint16'
        },
        {
          address: 1001,
          raw_value: 23456,
          parsed_value: '123.45',
          timestamp: '2025-09-09T12:34:56Z',
          success: true,
          data_type: 'float32'
        },
        {
          address: 1002,
          raw_value: 0,
          parsed_value: '',
          timestamp: '2025-09-09T12:34:56Z',
          success: false,
          error: 'ËøûÊé•Ë∂ÖÊó∂',
          data_type: 'uint16'
        }
      ],
      total_count: 3,
      success_count: 2,
      failed_count: 1,
      timestamp: '2025-09-09T12:34:56Z',
      duration_ms: 1200
    };

    beforeEach(() => {
      mockUseAddressRanges.mockReturnValue({
        ranges: [
          {
            id: '1',
            name: 'Range 1',
            startAddress: 1000,
            length: 3,
            dataType: 'uint16',
            enabled: true
          }
        ],
        addRange: vi.fn(),
        updateRange: vi.fn(),
        removeRange: vi.fn(),
        clearAllRanges: vi.fn(),
        validateRange: vi.fn(),
        checkOverlaps: vi.fn(),
        totalAddresses: 3,
        exportConfig: vi.fn(),
        importConfig: vi.fn(),
        isLoading: false,
        error: null
      });
    });

    it('ÊàêÂäüÊâßË°åËØªÂèñÊìç‰Ωú', async () => {
      mockInvoke.mockResolvedValue(mockBatchResult);

      render(
        <TooltipProvider>
          <DataReader connectionConfig={mockConnectionConfig} />
        </TooltipProvider>
      );

      const readButton = screen.getByRole('button', { name: /Á´ãÂç≥ËØªÂèñ/ });
      fireEvent.click(readButton);

      // È™åËØÅËØªÂèñ‰∏≠Áä∂ÊÄÅ
      expect(screen.getByText('ËØªÂèñ‰∏≠...')).toBeInTheDocument();
      expect(screen.getByText('ËØªÂèñ‰∏≠')).toBeInTheDocument();

      // Á≠âÂæÖËØªÂèñÂÆåÊàê
      await waitFor(() => {
        expect(screen.getByText('Â∑≤ÂÆåÊàê')).toBeInTheDocument();
      });

      // È™åËØÅË∞ÉÁî®‰∫ÜÊ≠£Á°ÆÁöÑAPI
      expect(mockInvoke).toHaveBeenCalledWith('read_modbus_ranges', {
        request: {
          ranges: [{ start: 1000, count: 3 }],
          format: 'dec'
        }
      });

      // È™åËØÅÊòæÁ§∫‰∫ÜÊàêÂäüÈÄöÁü•
      expect(mockNotifications.success).toHaveBeenCalledWith(
        'Êï∞ÊçÆËØªÂèñÂÆåÊàê',
        'ÊàêÂäüËØªÂèñ 2/3 ‰∏™Âú∞ÂùÄÔºåËÄóÊó∂ 1200ms'
      );

      // È™åËØÅÊòæÁ§∫‰∫ÜËØªÂèñÁªìÊûú
      expect(screen.getByText('ËØªÂèñÁªìÊûú')).toBeInTheDocument();
      expect(screen.getByText('2/3')).toBeInTheDocument();
    });

    it('Â§ÑÁêÜËØªÂèñÂ§±Ë¥•ÊÉÖÂÜµ', async () => {
      const errorMessage = 'ÁΩëÁªúËøûÊé•Â§±Ë¥•';
      mockInvoke.mockRejectedValue(new Error(errorMessage));

      render(
        <TooltipProvider>
          <DataReader connectionConfig={mockConnectionConfig} />
        </TooltipProvider>
      );

      const readButton = screen.getByRole('button', { name: /Á´ãÂç≥ËØªÂèñ/ });
      fireEvent.click(readButton);

      await waitFor(() => {
        expect(screen.getByText('ÈîôËØØ')).toBeInTheDocument();
      });

      // È™åËØÅÊòæÁ§∫‰∫ÜÈîôËØØ‰ø°ÊÅØ
      expect(screen.getByText(`ÊâπÈáèËØªÂèñÂ§±Ë¥•: Error: ${errorMessage}`)).toBeInTheDocument();

      // È™åËØÅË∞ÉÁî®‰∫ÜÈîôËØØÂ§ÑÁêÜ
      expect(mockHandleError).toHaveBeenCalled();
      expect(mockNotifications.error).toHaveBeenCalledWith(
        'ËØªÂèñÂ§±Ë¥•',
        `ÊâπÈáèËØªÂèñÂ§±Ë¥•: Error: ${errorMessage}`
      );
    });

    it('Â§ÑÁêÜÊó†ÂêØÁî®Âú∞ÂùÄÊÆµÁöÑÊÉÖÂÜµ', async () => {
      mockUseAddressRanges.mockReturnValue({
        ranges: [],
        addRange: vi.fn(),
        updateRange: vi.fn(),
        removeRange: vi.fn(),
        clearAllRanges: vi.fn(),
        validateRange: vi.fn(),
        checkOverlaps: vi.fn(),
        totalAddresses: 0,
        exportConfig: vi.fn(),
        importConfig: vi.fn(),
        isLoading: false,
        error: null
      });

      render(
        <TooltipProvider>
          <DataReader connectionConfig={mockConnectionConfig} />
        </TooltipProvider>
      );

      const readButton = screen.getByRole('button', { name: /Á´ãÂç≥ËØªÂèñ/ });
      fireEvent.click(readButton);

      // Á≠âÂæÖ‰∫ã‰ª∂Â§ÑÁêÜÂÆåÊàê
      await waitFor(() => {
        expect(mockNotifications.warning).toHaveBeenCalledWith(
          'Êó†ÂèØËØªÂèñÊï∞ÊçÆ',
          'ËØ∑ÂÖàÂú®Âú∞ÂùÄËåÉÂõ¥ÁÆ°ÁêÜ‰∏≠ÈÖçÁΩÆÂπ∂ÂêØÁî®Ëá≥Â∞ë‰∏Ä‰∏™Âú∞ÂùÄÊÆµ'
        );
      });

      // È™åËØÅÊ≤°ÊúâË∞ÉÁî®ËØªÂèñAPI
      expect(mockInvoke).not.toHaveBeenCalled();
    });

    it('ÊòæÁ§∫ËØªÂèñÁªìÊûúË°®Ê†º', async () => {
      mockInvoke.mockResolvedValue(mockBatchResult);

      render(
        <TooltipProvider>
          <DataReader connectionConfig={mockConnectionConfig} />
        </TooltipProvider>
      );

      const readButton = screen.getByRole('button', { name: /Á´ãÂç≥ËØªÂèñ/ });
      fireEvent.click(readButton);

      await waitFor(() => {
        expect(screen.getByText('Â∑≤ÂÆåÊàê')).toBeInTheDocument();
      });

      // È™åËØÅË°®Ê†ºÂ§¥
      expect(screen.getByText('Âú∞ÂùÄ')).toBeInTheDocument();
      expect(screen.getByText('ÂéüÂßãÂÄº')).toBeInTheDocument();
      expect(screen.getByText('Ëß£ÊûêÂÄº')).toBeInTheDocument();
      expect(screen.getByText('Á±ªÂûã')).toBeInTheDocument();
      expect(screen.getByText('Êó∂Èó¥Êà≥')).toBeInTheDocument();
      expect(screen.getByText('Áä∂ÊÄÅ')).toBeInTheDocument();

      // È™åËØÅÊï∞ÊçÆË°å
      expect(screen.getByText('1000')).toBeInTheDocument();
      expect(screen.getByText('12345')).toBeInTheDocument();
      expect(screen.getByText('1002')).toBeInTheDocument();

      // È™åËØÅÁªüËÆ°‰ø°ÊÅØ
      expect(screen.getByText('ÊàêÂäü 2')).toBeInTheDocument();
      expect(screen.getByText('Â§±Ë¥• 1')).toBeInTheDocument();
      expect(screen.getByText('Áî®Êó∂ 1.20s')).toBeInTheDocument();
    });
  });

  describe('Format Switching', () => {
    const mockResultWithNumbers = {
      results: [
        {
          address: 1000,
          raw_value: 255,
          parsed_value: '255',
          timestamp: '2025-09-09T12:34:56Z',
          success: true,
          data_type: 'uint16'
        }
      ],
      total_count: 1,
      success_count: 1,
      failed_count: 0,
      timestamp: '2025-09-09T12:34:56Z',
      duration_ms: 500
    };

    beforeEach(() => {
      mockUseAddressRanges.mockReturnValue({
        ranges: [
          {
            id: '1',
            name: 'Range 1',
            startAddress: 1000,
            length: 1,
            dataType: 'uint16',
            enabled: true
          }
        ],
        addRange: vi.fn(),
        updateRange: vi.fn(),
        removeRange: vi.fn(),
        clearAllRanges: vi.fn(),
        validateRange: vi.fn(),
        checkOverlaps: vi.fn(),
        totalAddresses: 1,
        exportConfig: vi.fn(),
        importConfig: vi.fn(),
        isLoading: false,
        error: null
      });
    });

    it('ÂàáÊç¢ÊòæÁ§∫Ê†ºÂºè', async () => {
      mockInvoke.mockResolvedValue(mockResultWithNumbers);

      render(
        <TooltipProvider>
          <DataReader connectionConfig={mockConnectionConfig} />
        </TooltipProvider>
      );

      // È¶ñÊ¨°ËØªÂèñ
      const readButton = screen.getByRole('button', { name: /Á´ãÂç≥ËØªÂèñ/ });
      fireEvent.click(readButton);

      await waitFor(() => {
        expect(screen.getByText('Â∑≤ÂÆåÊàê')).toBeInTheDocument();
      });

      // ÂàáÊç¢Âà∞ÂçÅÂÖ≠ËøõÂà∂Ê†ºÂºè
      const formatSelect = screen.getByRole('combobox');
      fireEvent.click(formatSelect);
      fireEvent.click(screen.getByText('ÂçÅÂÖ≠ËøõÂà∂'));

      // ÂÜçÊ¨°ËØªÂèñ‰ª•Â∫îÁî®Êñ∞Ê†ºÂºè
      fireEvent.click(readButton);

      await waitFor(() => {
        // È™åËØÅË∞ÉÁî®‰∫ÜÊ≠£Á°ÆÁöÑÊ†ºÂºè
        expect(mockInvoke).toHaveBeenLastCalledWith('read_modbus_ranges', {
          request: {
            ranges: [{ start: 1000, count: 1 }],
            format: 'hex'
          }
        });
      });
    });

    it('Á¶ÅÁî®ËØªÂèñÊó∂‰∏çËÉΩÂàáÊç¢Ê†ºÂºè', () => {
      mockUseAddressRanges.mockReturnValue({
        ranges: [
          {
            id: '1',
            name: 'Range 1',
            startAddress: 1000,
            length: 1,
            dataType: 'uint16',
            enabled: true
          }
        ],
        addRange: vi.fn(),
        updateRange: vi.fn(),
        removeRange: vi.fn(),
        clearAllRanges: vi.fn(),
        validateRange: vi.fn(),
        checkOverlaps: vi.fn(),
        totalAddresses: 1,
        exportConfig: vi.fn(),
        importConfig: vi.fn(),
        isLoading: false,
        error: null
      });

      render(
        <TooltipProvider>
          <DataReader connectionConfig={mockConnectionConfig} disabled={true} />
        </TooltipProvider>
      );

      const readButton = screen.getByRole('button', { name: /Á´ãÂç≥ËØªÂèñ/ });
      expect(readButton).toBeDisabled();
    });
  });

  describe('Error Handling', () => {
    beforeEach(() => {
      mockUseAddressRanges.mockReturnValue({
        ranges: [
          {
            id: '1',
            name: 'Range 1',
            startAddress: 1000,
            length: 1,
            dataType: 'uint16',
            enabled: true
          }
        ],
        addRange: vi.fn(),
        updateRange: vi.fn(),
        removeRange: vi.fn(),
        clearAllRanges: vi.fn(),
        validateRange: vi.fn(),
        checkOverlaps: vi.fn(),
        totalAddresses: 1,
        exportConfig: vi.fn(),
        importConfig: vi.fn(),
        isLoading: false,
        error: null
      });
    });

    it('Â§ÑÁêÜÊï∞ÊçÆÈ™åËØÅÂ§±Ë¥•', async () => {
      const invalidResult = {
        results: [],
        total_count: 1, // ‰∏çÂåπÈÖçÂÆûÈôÖÁªìÊûúÊï∞Èáè
        success_count: 0,
        failed_count: 0,
        timestamp: '2025-09-09T12:34:56Z',
        duration_ms: 500
      };

      mockInvoke.mockResolvedValue(invalidResult);

      render(
        <TooltipProvider>
          <DataReader connectionConfig={mockConnectionConfig} />
        </TooltipProvider>
      );

      const readButton = screen.getByRole('button', { name: /Á´ãÂç≥ËØªÂèñ/ });
      fireEvent.click(readButton);

      await waitFor(() => {
        expect(screen.getByText('ÈîôËØØ')).toBeInTheDocument();
      });
    });

    it('Â§ÑÁêÜÂÖ®ÈÉ®ËØªÂèñÂ§±Ë¥•ÁöÑÊÉÖÂÜµ', async () => {
      const allFailedResult = {
        results: [
          {
            address: 1000,
            raw_value: 0,
            parsed_value: '',
            timestamp: '2025-09-09T12:34:56Z',
            success: false,
            error: 'ËÆæÂ§áÊó†ÂìçÂ∫î',
            data_type: 'uint16'
          }
        ],
        total_count: 1,
        success_count: 0,
        failed_count: 1,
        timestamp: '2025-09-09T12:34:56Z',
        duration_ms: 5000
      };

      mockInvoke.mockResolvedValue(allFailedResult);

      render(
        <TooltipProvider>
          <DataReader connectionConfig={mockConnectionConfig} />
        </TooltipProvider>
      );

      const readButton = screen.getByRole('button', { name: /Á´ãÂç≥ËØªÂèñ/ });
      fireEvent.click(readButton);

      await waitFor(() => {
        expect(screen.getByText('ÈîôËØØ')).toBeInTheDocument();
      });

      await waitFor(() => {
        expect(mockNotifications.warning).toHaveBeenCalledWith(
          'ËØªÂèñÂÆåÊàê‰ΩÜÊó†Êï∞ÊçÆ',
          'ÊâÄÊúâ 1 ‰∏™Âú∞ÂùÄËØªÂèñÂ§±Ë¥•'
        );
      });
    });
  });
});